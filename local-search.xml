<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>anaconda换源</title>
    <link href="/2023/01/16/anaconda%E6%8D%A2%E6%BA%90/"/>
    <url>/2023/01/16/anaconda%E6%8D%A2%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h1 id="anaconda换源"><a href="#anaconda换源" class="headerlink" title="anaconda换源"></a>anaconda换源</h1><h2 id="国内anaconda安装包"><a href="#国内anaconda安装包" class="headerlink" title="国内anaconda安装包"></a>国内anaconda安装包</h2><p><code>https://mirrors.bfsu.edu.cn/anaconda/archive/</code></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>路径:<code> C:\Users\Administrator\ .condarc</code></p><blockquote><p>没有文件的话，创建一个就行</p></blockquote><p>增加文件内容</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">show_channel_urls: true<br>ssl_verify: true<br>channels:<br>  - https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>cloud<span class="hljs-regexp">/msys2/</span><br>  - https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>cloud/conda-forge<br>  - https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>pkgs<span class="hljs-regexp">/free/</span><br>  - defaults<br></code></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li>创建虚拟环境</li></ol><p><code>conda create -n &lt;condaName&gt; python=3.9.13</code></p><ol start="2"><li>切换虚拟环境</li></ol><p><code>conda activate &lt;condaName&gt;</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>anaconda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的SPI机制</title>
    <link href="/2023/01/04/Java%E7%9A%84SPI%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/01/04/Java%E7%9A%84SPI%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><blockquote><p>SPI 是Service Provider Interface 的缩写</p></blockquote><p>1 调用ServiceLoader重写后的hasNext方法，去查询实习类。<br>1.1 如果已经加载过了，则直接返回。没有的话，需要加载文件内容，然后加载class文件。<br>2 查询文件路径是META-INF/services/com.example.demo.dataSource.DataSource，其中这个文件名就是被实现接口的全限定名<br>2.1 加载文件内容，是通过使用java.lang.ClassLoader#getResources方法加载。</p><h2 id="SPI-在JDBC中的应用"><a href="#SPI-在JDBC中的应用" class="headerlink" title="SPI 在JDBC中的应用"></a>SPI 在JDBC中的应用</h2><p>DriverManager是java.sql下面的一个类，这个类会加载当前classpath下面所有的JDBC驱动。<br><strong>加载方式：</strong><br>在加载这个类时，执行了静态代码块(如下)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Load the initial JDBC drivers by checking the System property</span><br><span class="hljs-comment"> * jdbc.properties and then use the &#123;<span class="hljs-doctag">@code</span> ServiceLoader&#125; mechanism</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> &#123;<br>    loadInitialDrivers();<br>    println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>loadInitialDrivers()会加载当前classpath下面所有的JDBC驱动，然后注册到registeredDrivers集合内。<br>下面代码块是loadInitialDrivers()的核心内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1、使用SPI加载Driver的驱动类</span><br>ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);<br>Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123; <span class="hljs-comment">//2、寻找实现类的全限定名</span><br>        driversIterator.next(); <span class="hljs-comment">//3、实例化实现类（重点）</span><br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;<br><span class="hljs-comment">// Do nothing</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>重点是<code>driversIterator.next()</code>这个方法通过反射挨个实例化实现类。下面以mysql的驱动类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NonRegisteringDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.sql.Driver &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Driver</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            DriverManager.registerDriver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>());<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException var1) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在静态代码块中，Mysql的Driver，将自己注册到了DriverManager.registeredDrivers集合内。<br>正常使用时，<code>Connection connection = DriverManager.getConnection(url, userName, password);</code>这个过程就是在DriverManager.registeredDrivers集合内查找合适的驱动并返回JDBC链接。<br>查找的依据就是，调用Driver的实现类的acceptsURL(url)，各个数据库厂商的实现方式这里就不再举例。</p><p><em>加载各个厂商驱动的关键是，在jar里面都有META-INF/service/java.sql.Driver这个文件，文件内容是将要被加载到JVM的类全限定名</em></p><h2 id="SPI在SpringBoot中的应用"><a href="#SPI在SpringBoot中的应用" class="headerlink" title="SPI在SpringBoot中的应用"></a>SPI在SpringBoot中的应用</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Java,SPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO多路复用select、poll、epoll</title>
    <link href="/2022/12/29/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8select%E3%80%81poll%E3%80%81epoll/"/>
    <url>/2022/12/29/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8select%E3%80%81poll%E3%80%81epoll/</url>
    
    <content type="html"><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://juejin.cn/post/6882984260672847879#heading-13">彻底理解 IO 多路复用实现机制</a></p><p><a href="https://juejin.cn/post/6844904077621624845">NIO-WindowsSelectorImpl源码分析</a></p><p><a href="https://www.cnblogs.com/Jack-Blog/p/12394487.html">NIO-EPollSelectorIpml源码分析</a></p><p><a href="https://blog.csdn.net/daaikuaichuan/article/details/83862311">epoll原理详解及epoll反应堆模型</a></p><p><a href="https://www.jianshu.com/p/31cdfd6f5a48">彻底搞懂epoll高效运行的原理</a></p><hr><h3 id="IO多路复用-是一种IO模型，其含义是使用一个线程监控多个文件句柄。"><a href="#IO多路复用-是一种IO模型，其含义是使用一个线程监控多个文件句柄。" class="headerlink" title="IO多路复用 是一种IO模型，其含义是使用一个线程监控多个文件句柄。"></a>IO多路复用 是一种IO模型，其含义是使用一个线程监控多个文件句柄。</h3><p><strong>这里的文件句柄可以理解成socket链接</strong></p><h3 id="select、poll、epoll-是IO多路复用的三种实现方式"><a href="#select、poll、epoll-是IO多路复用的三种实现方式" class="headerlink" title="select、poll、epoll 是IO多路复用的三种实现方式"></a>select、poll、epoll 是IO多路复用的三种实现方式</h3><table><thead><tr><th></th><th>select</th><th>poll</th><th>epoll</th></tr></thead><tbody><tr><td>操作方式</td><td>遍历</td><td>遍历</td><td>回调</td></tr><tr><td>最大连接数</td><td>1024</td><td>无限制</td><td>无限制</td></tr><tr><td>时间效率</td><td>o(n)</td><td>o(n)</td><td>o(1)</td></tr><tr><td>是否阻塞</td><td>阻塞</td><td>阻塞</td><td>阻塞</td></tr><tr><td>消息传递</td><td>内核&lt;-&gt;用户</td><td>内核&lt;-&gt;用户</td><td>mmap</td></tr></tbody></table><h2 id="select工作方式"><a href="#select工作方式" class="headerlink" title="select工作方式"></a>select工作方式</h2><p>select将被监听的socket放入数组内。当数组内的socket有待处理数据，然后遍历整个数组查看哪些socket是待处理。</p><h3 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h3><p>将被监听的socket放入数组后，检查是否有待处理数据，没有的话向这些socket加入回调函数（可以理解成内应），随后阻塞当前线程。<br>当那些socket有了待处理数据（仅需1个即可），利用回调函数唤醒当前线程（但是并不知道哪些socket是待处理状态）。然后便利数组，挨个检查socket的状态。</p><h3 id="关于内存数据复制"><a href="#关于内存数据复制" class="headerlink" title="关于内存数据复制"></a>关于内存数据复制</h3><p>因为需要告诉操作系统，数组内的socket有了待处理数据之后唤醒自己，因此需要将数组数据复制到内核态空间。<br>然后当socket有了待处理数据，唤醒了自己后，那些数据还会被复制到用户态空间。</p><h3 id="note"><a href="#note" class="headerlink" title="note"></a>note</h3><p>socket的数组长度被限制1024个</p><h2 id="poll工作方式"><a href="#poll工作方式" class="headerlink" title="poll工作方式"></a>poll工作方式</h2><p>poll和select类似</p><h2 id="epoll工作方式"><a href="#epoll工作方式" class="headerlink" title="epoll工作方式"></a>epoll工作方式</h2><p>工作方式是事件驱动的。当被监听的socket有待处理数据，便会调用回调方法，将这个socket放入到一个链表中然后唤醒线程。<br>所以当线程被唤醒后只需要便利链表即可，这个链表上的节点都是待处理的socket。</p><h3 id="关于内存数据复制-1"><a href="#关于内存数据复制-1" class="headerlink" title="关于内存数据复制"></a>关于内存数据复制</h3><p>使用mmap的方式，是的内核态和用户态共享同一块内存，因此减少了不必要的数据拷贝。</p><h3 id="epoll的两种模式"><a href="#epoll的两种模式" class="headerlink" title="epoll的两种模式"></a>epoll的两种模式</h3><p>epoll支持水平触发（level trigger，LT) 或 边缘触发(edge trigger，ET)，默认是LT，水平触发。</p><p>两者区别是在epoll_wait方法调用时。</p><h4 id="水平触发（level-trigger，LT"><a href="#水平触发（level-trigger，LT" class="headerlink" title="水平触发（level trigger，LT)"></a>水平触发（level trigger，LT)</h4><p>每次调用epoll_wait方法时，只要存在待处理的I/O事件，就返回这些事件。</p><h4 id="边缘触发-edge-trigger，ET"><a href="#边缘触发-edge-trigger，ET" class="headerlink" title="边缘触发(edge trigger，ET)"></a>边缘触发(edge trigger，ET)</h4><p>每次调用epoll_wait方法时，如果待处理的I/O事件在之前的epoll_wait已经通知了，并且本次调用时这个socket没有新的I/O事件。则不再通知。</p><h4 id="水平触发（level-trigger，LT-和-边缘触发-edge-trigger，ET-的区别"><a href="#水平触发（level-trigger，LT-和-边缘触发-edge-trigger，ET-的区别" class="headerlink" title="水平触发（level trigger，LT) 和 边缘触发(edge trigger，ET) 的区别"></a>水平触发（level trigger，LT) 和 边缘触发(edge trigger，ET) 的区别</h4><p>如果存在大量不关心的I/O事件，使用LT模式，效率比较低。但是使用ET模式，则不需要处理大量无效的I/O事件。</p><h2 id="Java里Selector的实现方式"><a href="#Java里Selector的实现方式" class="headerlink" title="Java里Selector的实现方式"></a>Java里Selector的实现方式</h2><p>select、poll、epoll都是IO多路复用的实现。在Linux系统下优先使用epoll。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SelectorProvider <span class="hljs-title">create</span>()</span> &#123;<br>        String var0 = (String)AccessController.doPrivileged(<span class="hljs-keyword">new</span> GetPropertyAction(<span class="hljs-string">&quot;os.name&quot;</span>));<br>        <span class="hljs-keyword">if</span> (var0.<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;SunOS&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> createProvider(<span class="hljs-string">&quot;sun.nio.ch.DevPollSelectorProvider&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> (SelectorProvider)(var0.<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;Linux&quot;</span>) ? createProvider(<span class="hljs-string">&quot;sun.nio.ch.EPollSelectorProvider&quot;</span>) : <span class="hljs-keyword">new</span> PollSelectorProvider());<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 代码片段来自：openjdk-8u42-b03-linux-x64-14_jul_2022/sun.nio.ch.DefaultSelectorProvider#create</span><br></code></pre></td></tr></table></figure><h3 id="Java-NIO-空轮询BUG"><a href="#Java-NIO-空轮询BUG" class="headerlink" title="Java NIO 空轮询BUG"></a>Java NIO 空轮询BUG</h3><h4 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h4><p>在Linux环境下，selector.select() 方法会唤醒线程，但是却返回0。导致线程会无限循环。</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>在客户端出现RTS之后，Linux内核会更新事件集合，随后唤醒线程。但是有效的socket此时仍然是0.因此导致了，select()被唤醒却返回了0。</p><h4 id="Netty的解决方法"><a href="#Netty的解决方法" class="headerlink" title="Netty的解决方法"></a>Netty的解决方法</h4><p>在一定的时间内出现空循环次数达到一定的量。则重新创建一个selector，并把旧的selector里面有效的channel注册到新的selector。然后抛弃旧的selector。</p>]]></content>
    
    
    
    <tags>
      
      <tag>select,poll,epoll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java NIO与零拷贝</title>
    <link href="/2022/12/28/Java%20NIO%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <url>/2022/12/28/Java%20NIO%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<p>参考文章</p><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/16%20%20IO%20%E5%8A%A0%E9%80%9F%EF%BC%9A%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C%E7%9A%84%20Netty%20%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF.md">IO 加速：与众不同的 Netty 零拷贝技术</a><br><a href="https://baijiahao.baidu.com/s?id=1739827507938222078&wfr=spider&for=pc">彻底弄懂零拷贝、MMAP、堆外内存</a><br><a href="https://blog.csdn.net/l569590478/article/details/128178768">【Java技术专题】「原理专题」让我们一起探索一下Netty(Java)底层的“零拷贝Zero-Copy”技术（上）</a></p><h1 id="传统Linux零拷贝"><a href="#传统Linux零拷贝" class="headerlink" title="传统Linux零拷贝"></a>传统Linux零拷贝</h1><h3 id="零拷贝的定义：所谓的零拷贝是，不需要CPU的拷贝"><a href="#零拷贝的定义：所谓的零拷贝是，不需要CPU的拷贝" class="headerlink" title="零拷贝的定义：所谓的零拷贝是，不需要CPU的拷贝"></a>零拷贝的定义：所谓的零拷贝是，不需要CPU的拷贝</h3><p><img src="https://getdiea-images.oss-cn-beijing.aliyuncs.com/hexo/a4540de4-093e-47f1-bad0-bea8bc3b05bc.png" alt="下载服务器硬盘文件过程"></p><p>这个过程中1、3、4、6是系统用户态与内核态（内核态与用户态）的切换，<strong>这种切换往往伴随着内存数据的复制</strong></p><p><strong>过程</strong></p><ul><li>1 是应用程序向调用内核接口，读取硬盘中的数据。变化：用户态-》内核态，</li><li>2 内核读取硬盘数据到内核内存区域。这里使用DMA读取数据到指定内存空间</li><li>3 内核数据读取完成后，<font color=red >将内核内存中的数据在复制一份到用户空间。</font>并切换到用户态。变化：内核态-》用户态</li><li>4 应用程序调用内核接口，将用户态内存中的数据，写入socket通道并发送出去，用户态切换到内核态之后，也需要<font color=red >将用户态内存的数据复制到内核态内存。</font>变化：用户态-》内核态</li><li>5 使用DMA将内核态空间的数据通过网卡发送出去，随后切换会用户态。变化：内核态-》用户态</li></ul><h2 id="sendFile"><a href="#sendFile" class="headerlink" title="sendFile"></a>sendFile</h2><h4 id="上面流程中，3、4可以省略。使用Linux在2-1版本新增加的函数-sendFile-这个函数能够将数据从内核缓存直接复制到socket缓存空间"><a href="#上面流程中，3、4可以省略。使用Linux在2-1版本新增加的函数-sendFile-这个函数能够将数据从内核缓存直接复制到socket缓存空间" class="headerlink" title="上面流程中，3、4可以省略。使用Linux在2.1版本新增加的函数 sendFile(),这个函数能够将数据从内核缓存直接复制到socket缓存空间"></a>上面流程中，3、4可以省略。使用Linux在2.1版本新增加的函数 sendFile(),这个函数能够将数据从内核缓存直接<font color=red>复制</font>到socket缓存空间</h4><p><img src="https://getdiea-images.oss-cn-beijing.aliyuncs.com/hexo/cc53a094-0f4b-48c6-84b5-5d7ef2f79b9a.png" alt="使用sendFile流程"><br>与传统的IO流程对比。少了一次CPU Copy和两次状态切换</p><h4 id="上面仍然存在一次CPU-Copy。在支持-scatter-gather-特性的-sendFile-的-IO-流程中，这个步骤也可以省略。"><a href="#上面仍然存在一次CPU-Copy。在支持-scatter-gather-特性的-sendFile-的-IO-流程中，这个步骤也可以省略。" class="headerlink" title="上面仍然存在一次CPU Copy。在支持 scatter-gather 特性的 sendFile 的 IO 流程中，这个步骤也可以省略。"></a>上面仍然存在一次CPU Copy。在支持 scatter-gather 特性的 sendFile 的 IO 流程中，这个步骤也可以省略。</h4><p><img src="https://getdiea-images.oss-cn-beijing.aliyuncs.com/hexo/4ea69db3-960b-45db-a1c3-c4f678059cc0.png" alt="支持 scatter-gather 特性的 sendFile"><br>再次减少CPU Copy，只需要文件描述符和长度，网卡就可以读取内核数据。这种状态下只有<font color=red>两次状态切换，0次CPU Copy。</font></p><h1 id="Netty-零拷贝"><a href="#Netty-零拷贝" class="headerlink" title="Netty 零拷贝"></a>Netty 零拷贝</h1><h3 id="Netty-本身支持上述过程中的IO流程"><a href="#Netty-本身支持上述过程中的IO流程" class="headerlink" title="Netty 本身支持上述过程中的IO流程"></a>Netty 本身支持上述过程中的IO流程</h3><p>另外netty还提供了丰富的API，用于解决在编码过程中遇到的数据拷贝的问题。<br>特点：</p><ul><li>堆外内存</li><li>CompositeByteBuf 类</li><li>Unpooled.wrappedBuffer 类</li><li>ByteBuf.slice</li><li>FileRegion</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Netty, NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
