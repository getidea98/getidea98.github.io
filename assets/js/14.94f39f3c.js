(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{415:function(t,a,e){"use strict";e.r(a);var r=e(34),l=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"动态代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态代理"}},[t._v("#")]),t._v(" 动态代理")]),t._v(" "),e("p",[t._v("tag: Java基础")]),t._v(" "),e("h2",{attrs:{id:"jdk-动态代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jdk-动态代理"}},[t._v("#")]),t._v(" jdk 动态代理")]),t._v(" "),e("p",[t._v("jdk动态代理的步骤")]),t._v(" "),e("ol",[e("li",[t._v("通过实现 InvocationHandler 接口创建自己的调用处理器；")]),t._v(" "),e("li",[t._v("通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；")]),t._v(" "),e("li",[t._v("通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；")]),t._v(" "),e("li",[t._v("通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。")])]),t._v(" "),e("h2",{attrs:{id:"gclib动态代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gclib动态代理"}},[t._v("#")]),t._v(" gclib动态代理")]),t._v(" "),e("ol",[e("li",[t._v("调用代理类方法。")]),t._v(" "),e("li",[t._v("代理类方法中触发拦截器方法。")]),t._v(" "),e("li",[t._v("拦截器中触发MethodProxy.invokeSuper方法，并获取需要调用的代理类方法索引。")]),t._v(" "),e("li",[t._v("执行Fast索引类方法，根据代理类方法索引，获得代理类方法。")]),t._v(" "),e("li",[t._v("执行代理类中代理方法，通过super()方法完成真实逻辑调用。")])]),t._v(" "),e("p",[e("a",{attrs:{href:"https://my.oschina.net/itblog/blog/4715745",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://my.oschina.net/itblog/blog/4715745"),e("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=l.exports}}]);