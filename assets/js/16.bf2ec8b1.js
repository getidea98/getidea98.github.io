(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{417:function(t,s,a){"use strict";a.r(s);var n=a(34),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"java锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java锁"}},[t._v("#")]),t._v(" Java锁")]),t._v(" "),a("p",[t._v("tag: Java基础")]),t._v(" "),a("h2",{attrs:{id:"悲观锁与乐观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#悲观锁与乐观锁"}},[t._v("#")]),t._v(" 悲观锁与乐观锁")]),t._v(" "),a("p",[a("strong",[t._v("悲观锁：读写都会加锁。因此适合在写数据多的情况。")])]),t._v(" "),a("p",[a("strong",[t._v("乐观锁：读数据不会加锁，写数据才会加锁。因此适合读多写少的情况。")])]),t._v(" "),a("h3",{attrs:{id:"悲观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#悲观锁"}},[t._v("#")]),t._v(" 悲观锁：")]),t._v(" "),a("p",[t._v("Java的synchronized和Lock就是悲观锁。")]),t._v(" "),a("h3",{attrs:{id:"乐观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁"}},[t._v("#")]),t._v(" 乐观锁：")]),t._v(" "),a("p",[t._v("乐观锁在Java中是通过无锁编程实现的。原子类的递增操作就是通过CAS自旋实现的。")]),t._v(" "),a("p",[a("strong",[t._v("CAS:")])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicInteger")]),t._v(" atomicInteger "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicInteger")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        atomicInteger"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("incrementAndGet")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// AtomicInteger")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("incrementAndGet")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" unsafe"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getAndAddInt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" valueOffset"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Unsafe")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getAndAddInt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" o"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" offset"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" delta"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            v "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getIntVolatile")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" offset"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSwapInt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" offset"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" v "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" delta"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("CAS在实现有问题，那就是ABA问题。解决办法是变量前面加版本号。")]),t._v(" "),a("h3",{attrs:{id:"自旋锁与自适应自旋锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自旋锁与自适应自旋锁"}},[t._v("#")]),t._v(" 自旋锁与自适应自旋锁")]),t._v(" "),a("p",[t._v("线程获取不到锁有两种处理方式：1. 线程阻塞 2.线程自旋")]),t._v(" "),a("p",[t._v("自旋锁：线程获取不到锁的时候，循环的执行空代码。")]),t._v(" "),a("p",[t._v("自适应自旋锁：循环次数不是固定的，而是由上次循环情况和锁的拥有者的状态决定。")]),t._v(" "),a("p",[t._v("线程一旦被阻塞，再次被唤醒时代价较大。因此适当的采用自旋锁可以提高效率。")]),t._v(" "),a("h3",{attrs:{id:"独享锁与共享锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#独享锁与共享锁"}},[t._v("#")]),t._v(" 独享锁与共享锁")]),t._v(" "),a("p",[t._v("独享锁也叫排他锁、互斥锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。")]),t._v(" "),a("p",[t._v("共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。")]),t._v(" "),a("h3",{attrs:{id:"可重入锁-vs-非可重入锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可重入锁-vs-非可重入锁"}},[t._v("#")]),t._v(" 可重入锁 VS 非可重入锁")]),t._v(" "),a("h3",{attrs:{id:"公平锁-vs-非公平锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#公平锁-vs-非公平锁"}},[t._v("#")]),t._v(" 公平锁 VS 非公平锁")]),t._v(" "),a("h2",{attrs:{id:"锁升级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁升级"}},[t._v("#")]),t._v(" 锁升级")]),t._v(" "),a("h3",{attrs:{id:"无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁"}},[t._v("#")]),t._v(" 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁")]),t._v(" "),a("p",[t._v("针对synchronized锁的四种状态。")]),t._v(" "),a("p",[a("strong",[t._v("偏向锁")])]),t._v(" "),a("p",[t._v("通过对比Mark Word中的信息，判断当前线程是否拥有当前对象锁，避免通过CAS原子操作。")]),t._v(" "),a("p",[t._v("拥有偏向锁的线程只需要和MarkWord里的信息对比下，然后执行。")]),t._v(" "),a("p",[a("strong",[t._v("轻量级锁")])]),t._v(" "),a("p",[t._v("是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。")]),t._v(" "),a("p",[a("strong",[t._v("重量级锁")])]),t._v(" "),a("p",[t._v("若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。")])])}),[],!1,null,null,null);s.default=r.exports}}]);