(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{426:function(t,r,a){"use strict";a.r(r);var e=a(34),s=Object(e.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"aqs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aqs"}},[t._v("#")]),t._v(" AQS")]),t._v(" "),a("h3",{attrs:{id:"同步器aqs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步器aqs"}},[t._v("#")]),t._v(" 同步器AQS")]),t._v(" "),a("p",[a("strong",[t._v("同步队列")])]),t._v(" "),a("p",[t._v("同步队列是同步器AQS内部依赖的队列（双向队列FIFO）。那些尝试获取同步状态，失败的线程会被放入队列的尾部，并被阻塞，直到节点出队，才被唤醒（由上一个释放同步状态的线程唤醒）。")]),t._v(" "),a("p",[t._v("队列的每一个节点，都是Node对象。而这个对象内部封装着：")]),t._v(" "),a("p",[t._v("节点状态、当前线程对象（thread）、前后节点、当前获取同步状态的线程引用。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/imgs/TheArtOfJavaConcurrentProgramming/AQS1.png",alt:"Untitled"}})]),t._v(" "),a("p",[t._v("同步器，持有队列的头/尾节点，没有获取成功的节点会被放入尾节点。但是这个过程必须保证线程安全。因为会有多个线程尝试获取同步状态，绝大部分会失败。如何保证线程安全？")]),t._v(" "),a("p",[t._v("native compareAndSetTail(Node expect,Node update)。基于CAS的方式")]),t._v(" "),a("p",[a("img",{attrs:{src:"/imgs/TheArtOfJavaConcurrentProgramming/AQS1.png",alt:"同步器将节点加入到同步队列的过程"}})]),t._v(" "),a("p",[t._v("同步器将节点加入到同步队列的过程")]),t._v(" "),a("p",[t._v("同步队列的首节点是正在执行的节点（线程）。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/imgs/TheArtOfJavaConcurrentProgramming/AQS1.png",alt:"首节点的设置"}})]),t._v(" "),a("p",[t._v("首节点的设置")]),t._v(" "),a("p",[t._v("首节点在释放同步状态后会唤醒后续节点。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/imgs/TheArtOfJavaConcurrentProgramming/AQS1.png",alt:"节点自旋的获取同步状态"}})]),t._v(" "),a("p",[t._v("节点自旋的获取同步状态")])])}),[],!1,null,null,null);r.default=s.exports}}]);