(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{432:function(t,n,i){"use strict";i.r(n);var o=i(34),a=Object(o.a)({},(function(){var t=this,n=t.$createElement,i=t._self._c||n;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"锁降级与condition接口"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#锁降级与condition接口"}},[t._v("#")]),t._v(" 锁降级与Condition接口")]),t._v(" "),i("p",[t._v("锁降级")]),t._v(" "),i("p",[t._v("当前线程拥有写锁，随后在拥有读锁，然后释放写锁。至此完成锁降级，此线程只拥有读锁，完成锁降级")]),t._v(" "),i("h2",{attrs:{id:"condition"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#condition"}},[t._v("#")]),t._v(" "),i("strong",[t._v("Condition")])]),t._v(" "),i("p",[i("img",{attrs:{src:"/imgs/TheArtOfJavaConcurrentProgramming/%E9%94%81%E9%99%8D%E7%BA%A7%E4%B8%8ECondition%E6%8E%A5%E5%8F%A31.png",alt:"Object的监视器方法与Condition接口的对比"}})]),t._v(" "),i("p",[t._v("Object的监视器方法与Condition接口的对比")]),t._v(" "),i("p",[t._v("线程从await()方法返回，需要重新竞争锁资源。")]),t._v(" "),i("h3",{attrs:{id:"condition的内部实现"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#condition的内部实现"}},[t._v("#")]),t._v(" "),i("strong",[t._v("Condition的内部实现")])]),t._v(" "),i("p",[i("strong",[t._v("等待队列")])]),t._v(" "),i("p",[t._v("等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程。如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。")]),t._v(" "),i("p",[i("img",{attrs:{src:"/imgs/TheArtOfJavaConcurrentProgramming/%E9%94%81%E9%99%8D%E7%BA%A7%E4%B8%8ECondition%E6%8E%A5%E5%8F%A32.png",alt:"等待队列的基本结构"}})]),t._v(" "),i("p",[t._v("等待队列的基本结构")]),t._v(" "),i("p",[t._v("在Object的拥有一个同步队列和一个等待队列。但是Lock接口，拥有一个同步队列和多个等待队列")]),t._v(" "),i("p",[i("img",{attrs:{src:"/imgs/TheArtOfJavaConcurrentProgramming/%E9%94%81%E9%99%8D%E7%BA%A7%E4%B8%8ECondition%E6%8E%A5%E5%8F%A33.png",alt:"Untitled"}})]),t._v(" "),i("p",[i("strong",[t._v("等待")])]),t._v(" "),i("p",[t._v("调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释 放锁，同时线程状态变为等待状态。")]),t._v(" "),i("p",[t._v("当从await()方法返回时，当前线程一定获取了Condition相 关联的锁。")]),t._v(" "),i("p",[t._v("调用await()方法时，将自己添加到等待队列，随后唤醒后续节点。")]),t._v(" "),i("p",[i("strong",[t._v("通知")])]),t._v(" "),i("p",[t._v("调用Condition的signal()方法，会将队列的首节点放到同步队列的末尾。随后唤醒节点，是指自己加入到同步队列。")]),t._v(" "),i("p",[i("img",{attrs:{src:"/imgs/TheArtOfJavaConcurrentProgramming/%E9%94%81%E9%99%8D%E7%BA%A7%E4%B8%8ECondition%E6%8E%A5%E5%8F%A34.png",alt:"Untitled"}})])])}),[],!1,null,null,null);n.default=a.exports}}]);